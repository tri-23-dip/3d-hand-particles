<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Hand Particles â€¢ HYPER INTERACTIVE</title>

<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { overflow:hidden; background:#000; font-family:Inter,system-ui,sans-serif; }

#ui {
    position:absolute; top:20px; left:20px; z-index:10;
    background:rgba(5,15,25,.85); backdrop-filter:blur(12px);
    padding:20px 30px; border-radius:40px;
    border:1px solid rgba(0,255,255,.5);
    color:white;
}

#gesture-name {
    font-size:2rem;
    font-weight:800;
    background:linear-gradient(45deg,#0ff,#f0f);
    -webkit-background-clip:text;
    color:transparent;
}

button {
    margin-top:10px;
    background:linear-gradient(45deg,#0ff,#80f);
    border:none;
    padding:10px 20px;
    border-radius:30px;
    cursor:pointer;
    color:white;
    font-weight:bold;
}

canvas { display:block; }
</style>
</head>

<body>

<div id="ui">
    <div id="gesture-name">SPHERE</div>
    <button onclick="toggleRotate()">Toggle Rotate (Space)</button>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

const PARTICLES = 15000;
let currentMode = "SPHERE";
let autoRotate = false;
let morphProgress = 1;
let targetPositions = [];

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x050510);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 12;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
document.body.appendChild(renderer.domElement);

const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLES * 3);
const colors = new Float32Array(PARTICLES * 3);

for(let i=0;i<PARTICLES;i++){
    positions[i*3] = (Math.random()-0.5)*20;
    positions[i*3+1] = (Math.random()-0.5)*20;
    positions[i*3+2] = (Math.random()-0.5)*20;

    const color = new THREE.Color().setHSL(Math.random(),0.8,0.6);
    colors[i*3]=color.r;
    colors[i*3+1]=color.g;
    colors[i*3+2]=color.b;
}

geometry.setAttribute("position", new THREE.BufferAttribute(positions,3));
geometry.setAttribute("color", new THREE.BufferAttribute(colors,3));

const material = new THREE.PointsMaterial({
    size:0.07,
    vertexColors:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false
});

const points = new THREE.Points(geometry, material);
scene.add(points);

/* ---------------- SHAPES ---------------- */

function generateShape(mode){
    const arr = [];
    for(let i=0;i<PARTICLES;i++){
        let x,y,z;

        if(mode==="SPHERE"){
            const r=5*Math.cbrt(Math.random());
            const theta=Math.random()*2*Math.PI;
            const phi=Math.acos(2*Math.random()-1);
            x=r*Math.sin(phi)*Math.cos(theta);
            y=r*Math.sin(phi)*Math.sin(theta);
            z=r*Math.cos(phi);
        }

        if(mode==="TORUS"){
            const R=4, r=1.5;
            const u=Math.random()*2*Math.PI;
            const v=Math.random()*2*Math.PI;
            x=(R+r*Math.cos(v))*Math.cos(u);
            y=(R+r*Math.cos(v))*Math.sin(u);
            z=r*Math.sin(v);
        }

        if(mode==="WAVE"){
            x=(Math.random()-0.5)*10;
            y=(Math.random()-0.5)*10;
            z=Math.sin(x)*Math.cos(y)*2;
        }

        if(mode==="STAR"){
            const angle=Math.random()*Math.PI*2;
            const radius = Math.random()<0.5 ? 5 : 2.5;
            x=Math.cos(angle)*radius;
            y=Math.sin(angle)*radius;
            z=(Math.random()-0.5)*2;
        }

        if(mode==="HEART"){
            const t=Math.random()*Math.PI*2;
            x=3*Math.pow(Math.sin(t),3);
            y=3*(Math.cos(t)-Math.cos(2*t)/2-Math.cos(3*t)/6-Math.cos(4*t)/24);
            z=(Math.random()-0.5)*2;
        }

        arr.push(x,y,z);
    }
    return arr;
}

function setMode(mode){
    currentMode=mode;
    document.getElementById("gesture-name").innerText=mode;
    targetPositions = generateShape(mode);
    morphProgress = 0;
}

window.addEventListener("keydown",(e)=>{
    if(e.key==="1") setMode("SPHERE");
    if(e.key==="2") setMode("HEART");
    if(e.key==="3") setMode("STAR");
    if(e.key==="4") setMode("TORUS");
    if(e.key==="5") setMode("WAVE");
    if(e.key===" ") autoRotate=!autoRotate;
});

window.toggleRotate = ()=> autoRotate=!autoRotate;

/* ---------------- ANIMATION ---------------- */

function animate(){
    requestAnimationFrame(animate);

    const pos = geometry.attributes.position.array;

    if(morphProgress < 1){
        morphProgress += 0.02;
        for(let i=0;i<pos.length;i++){
            pos[i] += (targetPositions[i]-pos[i]) * 0.08;
        }
        geometry.attributes.position.needsUpdate = true;
    }

    if(autoRotate){
        points.rotation.y += 0.005;
        points.rotation.x += 0.002;
    }

    renderer.render(scene,camera);
}

animate();

window.addEventListener("resize",()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});
</script>

</body>
</html>