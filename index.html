<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hand Particles ‚Ä¢ HYPER INTERACTIVE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; font-family: 'Inter', system-ui, sans-serif; }
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            background: rgba(5, 15, 25, 0.8); backdrop-filter: blur(12px);
            padding: 24px 32px; border-radius: 60px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.2);
            color: white; pointer-events: none;
            transition: all 0.3s ease;
        }
        #status { font-size: 0.9rem; letter-spacing: 2px; color: #8ff; }
        #gesture-name { 
            font-size: 2.5rem; font-weight: 800; margin-top: 5px;
            background: linear-gradient(45deg, #0ff, #f0f);
            /* Vendor prefixes for background-clip */
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px cyan;
        }
        #mode-icons {
            display: flex; gap: 15px; margin: 15px 0 10px;
            font-size: 2rem; filter: drop-shadow(0 0 10px cyan);
        }
        .icon { opacity: 0.4; transition: all 0.2s; transform: scale(0.8); }
        .icon.active { opacity: 1; transform: scale(1.2); text-shadow: 0 0 20px cyan; }
        #start-btn {
            background: linear-gradient(135deg, #0ff, #80f);
            color: white; border: none; padding: 14px 32px;
            font-weight: bold; cursor: pointer; border-radius: 40px; 
            font-size: 1.2rem; letter-spacing: 1px; transition: 0.2s;
            box-shadow: 0 0 30px cyan; border: 1px solid rgba(255,255,255,0.5);
            pointer-events: auto; text-transform: uppercase;
        }
        #start-btn:hover { 
            transform: scale(1.05); box-shadow: 0 0 60px cyan;
            filter: brightness(1.2);
        }
        #stats {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
            padding: 15px 25px; border-radius: 40px;
            border: 1px solid #0ff; color: #0ff;
            font-family: monospace; font-size: 1.2rem;
            text-align: right;
        }
        #stats div { margin: 5px 0; }
        #fps { color: #ff0; }
        .hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
            color: white; padding: 12px 24px; border-radius: 40px;
            border: 1px solid #0ff; font-size: 1rem;
            white-space: nowrap; z-index: 99;
            pointer-events: none;
        }
        video { display: none; }
        canvas { display: block; }
        .particle-count { color: #f0f; }
    </style>
</head>
<body>

<div id="ui">
    <div id="status">‚ö° SYSTEM READY</div>
    <div id="mode-icons">
        <span class="icon active" id="icon-sphere">‚ö™</span>
        <span class="icon" id="icon-heart">‚ù§Ô∏è</span>
        <span class="icon" id="icon-star">‚≠ê</span>
        <span class="icon" id="icon-torus">üåÄ</span>
        <span class="icon" id="icon-wave">üåä</span>
    </div>
    <div id="gesture-name">SPHERE</div>
    <button id="start-btn">üé• ACTIVATE CAMERA</button>
</div>

<div id="stats">
    <div>üéØ MODE: <span id="stat-mode">SPHERE</span></div>
    <div>‚úã HAND: <span id="stat-hand">WAITING</span></div>
    <div>‚ö° FPS: <span id="fps">60</span></div>
    <div>üîÆ PARTICLES: <span class="particle-count" id="particle-count">15k</span></div>
</div>

<div class="hint">üëÜ MOVE HAND ‚Ä¢ OPEN PALM = SPIRAL ‚Ä¢ CLOSE FIST = EXPLODE ‚Ä¢ PINCH = WAVE</div>

<video id="video" autoplay playsinline></video>

<script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
    import * as THREE from 'three';
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    // --- CONFIGURATION ---
    const PARTICLE_COUNT = 15000; // More particles for richer effects
    const RESPONSE_SPEED = 0.25; // Faster interpolation (was 0.12)
    const HAND_SMOOTHING = 0.35; // Faster hand follow
    
    let handLandmarker, video, lastVideoTime = -1;
    const targetPositions = new Float32Array(PARTICLE_COUNT * 3);
    const basePositions = new Float32Array(PARTICLE_COUNT * 3); // For wave effects
    let currentMode = 'SPHERE';
    let handVisible = false;
    let fistIntensity = 0; // 0-1 for fist effect
    let waveTime = 0;
    
    // FPS calculation
    let lastTime = performance.now();
    let frames = 0;
    let fps = 60;

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x030614);
    
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1, 14);
    
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS & ATMOSPHERE ---
    scene.fog = new THREE.FogExp2(0x030614, 0.02);
    
    // Add a subtle grid floor for depth reference
    const gridHelper = new THREE.GridHelper(20, 20, 0x0ff, 0x306080);
    gridHelper.position.y = -3;
    gridHelper.material.opacity = 0.15;
    gridHelper.material.transparent = true;
    scene.add(gridHelper);

    // --- MAIN PARTICLES ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(PARTICLE_COUNT * 3);
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    
    // Initialize random cloud and colors
    for (let i = 0; i < PARTICLE_COUNT; i++) {
        positions[i*3] = (Math.random() - 0.5) * 20;
        positions[i*3+1] = (Math.random() - 0.5) * 20;
        positions[i*3+2] = (Math.random() - 0.5) * 20;
        
        // Store base positions for wave effects
        basePositions[i*3] = positions[i*3];
        basePositions[i*3+1] = positions[i*3+1];
        basePositions[i*3+2] = positions[i*3+2];
        
        // Rainbow colors
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 0.9, 0.6);
        colors[i*3] = color.r;
        colors[i*3+1] = color.g;
        colors[i*3+2] = color.b;
    }
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({ 
        size: 0.07, 
        vertexColors: true, 
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        sizeAttenuation: true
    });
    
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // --- SHAPE GENERATORS (FAST) ---
    function computeTargetPositions(shape, fistFactor = 0) {
        const now = performance.now() / 300;
        
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let x, y, z;
            const t = (i / PARTICLE_COUNT) * Math.PI * 2;
            
            switch(shape) {
                case 'HEART':
                    const scale = 0.45;
                    const hx = 16 * Math.pow(Math.sin(t), 3) * scale;
                    const hy = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * scale;
                    x = hx;
                    y = hy + 1; // Center vertically
                    z = (Math.random() - 0.5) * 1.5;
                    break;
                    
                case 'STAR':
                    const r1 = 4;
                    const r2 = 2;
                    const points = 5;
                    const phase = (i % 50) / 25 * Math.PI;
                    const angle = (i * 0.01) * Math.PI * 2;
                    const starRad = (i % 2 === 0) ? r1 : r2;
                    x = Math.cos(angle * points + phase) * starRad;
                    y = Math.sin(angle * points + phase) * starRad;
                    z = Math.sin(angle * 3) * 2;
                    break;
                    
                case 'TORUS':
                    const R = 5;
                    const rTube = 1.5;
                    const u = t;
                    const v = (i * 0.1) % (Math.PI * 2);
                    x = (R + rTube * Math.cos(v)) * Math.cos(u);
                    y = (R + rTube * Math.cos(v)) * Math.sin(u);
                    z = rTube * Math.sin(v);
                    break;
                    
                case 'WAVE':
                    const w = (i * 0.01) * Math.PI * 2;
                    x = Math.sin(w * 2 + now) * 5;
                    y = Math.cos(w * 3) * 3;
                    z = w * 2 - 6;
                    break;
                    
                default: // SPHERE with fist distortion
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const sphereRad = 4.5 * (1 + fistFactor * 0.5 * Math.sin(theta * 5) * Math.sin(phi * 5));
                    x = sphereRad * Math.sin(phi) * Math.cos(theta);
                    y = sphereRad * Math.sin(phi) * Math.sin(theta);
                    z = sphereRad * Math.cos(phi);
            }
            
            targetPositions[i*3] = x;
            targetPositions[i*3+1] = y;
            targetPositions[i*3+2] = z;
        }
    }
    
    computeTargetPositions('SPHERE');

    // --- UI ELEMENTS ---
    const modeIcons = {
        'SPHERE': document.getElementById('icon-sphere'),
        'HEART': document.getElementById('icon-heart'),
        'STAR': document.getElementById('icon-star'),
        'TORUS': document.getElementById('icon-torus'),
        'WAVE': document.getElementById('icon-wave')
    };
    
    function setMode(mode) {
        if (mode === currentMode) return;
        currentMode = mode;
        
        // Update UI
        document.getElementById('gesture-name').innerText = mode;
        document.getElementById('stat-mode').innerText = mode;
        
        // Update icons
        Object.values(modeIcons).forEach(icon => icon.classList.remove('active'));
        if (modeIcons[mode]) modeIcons[mode].classList.add('active');
        
        // Compute new target positions
        computeTargetPositions(mode, fistIntensity);
    }

    // --- HAND TRACKING SETUP ---
    async function startExperience() {
        document.getElementById('status').innerHTML = "üîç LOADING AI MODEL...";
        try {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { 
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", 
                    delegate: "GPU" 
                },
                runningMode: "VIDEO", 
                numHands: 1,
                minHandDetectionConfidence: 0.3,
                minHandPresenceConfidence: 0.3,
                minTrackingConfidence: 0.3
            });

            video = document.getElementById("video");
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { 
                    facingMode: "user",
                    width: { ideal: 640 },
                    height: { ideal: 480 }
                } 
            });
            video.srcObject = stream;
            
            await new Promise((resolve) => {
                video.onloadedmetadata = () => { video.play(); resolve(); };
            });
            
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('status').innerHTML = "‚ú® HAND TRACKING ACTIVE";
            document.getElementById('stat-hand').innerHTML = "DETECTING";
            lastVideoTime = video.currentTime;
        } catch (err) {
            document.getElementById('status').innerHTML = "‚ùå ERROR: " + err.message;
        }
    }

    document.getElementById('start-btn').addEventListener('click', startExperience);

    // --- FPS COUNTER ---
    function updateFPS() {
        frames++;
        const now = performance.now();
        const delta = now - lastTime;
        if (delta >= 1000) {
            fps = frames;
            document.getElementById('fps').innerText = fps;
            frames = 0;
            lastTime = now;
        }
    }

    // --- ANIMATION LOOP ---
    function animate() {
        updateFPS();
        waveTime += 0.02;
        
        // Hand tracking
        if (handLandmarker && video?.readyState === 4 && video.currentTime !== lastVideoTime) {
            try {
                const results = handLandmarker.detectForVideo(video, performance.now());
                
                if (results.landmarks && results.landmarks.length > 0) {
                    const hand = results.landmarks[0];
                    handVisible = true;
                    document.getElementById('stat-hand').innerHTML = "‚úÖ TRACKING";
                    
                    // Faster hand movement
                    const targetX = -(hand[8].x - 0.5) * 14;
                    const targetY = -(hand[8].y - 0.5) * 10;
                    
                    points.position.x += (targetX - points.position.x) * HAND_SMOOTHING;
                    points.position.y += (targetY - points.position.y) * HAND_SMOOTHING;
                    
                    // FIST DETECTION (distance between fingers)
                    const thumbTip = hand[4];
                    const indexTip = hand[8];
                    const dist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y, thumbTip.z - indexTip.z);
                    fistIntensity = Math.max(0, Math.min(1, 1 - dist * 3)); // 0 = open, 1 = closed
                    
                    // PINCH DETECTION (thumb to middle finger)
                    const middleTip = hand[12];
                    const pinchDist = Math.hypot(thumbTip.x - middleTip.x, thumbTip.y - middleTip.y);
                    const isPinching = pinchDist < 0.1;
                    
                    // MODE SELECTION based on hand position + gestures
                    const handY = hand[8].y;
                    const handX = hand[8].x;
                    
                    if (isPinching) {
                        setMode('WAVE');
                    } else if (fistIntensity > 0.6) {
                        setMode('STAR'); // Fist = explode/star
                    } else if (handY < 0.3) {
                        setMode('HEART');
                    } else if (handY > 0.7) {
                        setMode('TORUS');
                    } else if (handX < 0.3) {
                        setMode('SPHERE');
                    } else {
                        setMode('HEART');
                    }
                    
                    // Recompute target with fist distortion if needed
                    if (currentMode === 'SPHERE' && fistIntensity > 0.1) {
                        computeTargetPositions('SPHERE', fistIntensity);
                    } else if (currentMode === 'WAVE') {
                        computeTargetPositions('WAVE');
                    }
                    
                } else {
                    if (handVisible) {
                        document.getElementById('stat-hand').innerHTML = "‚è≥ NO HAND";
                        handVisible = false;
                    }
                    // Drift back
                    points.position.x += (0 - points.position.x) * 0.02;
                    points.position.y += (0 - points.position.y) * 0.02;
                }
            } catch (e) {
                // Ignore tracking errors
            }
            lastVideoTime = video.currentTime;
        }

        // SUPER FAST PARTICLE INTERPOLATION
        const posAttr = geometry.attributes.position.array;
        
        // Fast loop
        for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
            // Faster response with adaptive speed
            const speed = RESPONSE_SPEED * (1 + fistIntensity * 0.5);
            
            posAttr[i] += (targetPositions[i] - posAttr[i]) * speed;
            posAttr[i+1] += (targetPositions[i+1] - posAttr[i+1]) * speed;
            posAttr[i+2] += (targetPositions[i+2] - posAttr[i+2]) * speed;
        }
        
        // Add wave motion if in wave mode
        if (currentMode === 'WAVE') {
            for (let i = 0; i < PARTICLE_COUNT * 3; i += 3) {
                posAttr[i+1] += Math.sin(waveTime + posAttr[i] * 0.5) * 0.02;
            }
        }
        
        geometry.attributes.position.needsUpdate = true;
        
        // Auto-rotate camera slightly when no hand
        if (!handVisible) {
            camera.lookAt(0, 0, 0);
        } else {
            camera.lookAt(points.position.x, points.position.y, 0);
        }
        
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    // Start animation loop
    animate();

    // Resize handler
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Initial UI setup
    document.getElementById('particle-count').innerText = (PARTICLE_COUNT/1000).toFixed(0) + 'k';
</script>
</body>
</html>